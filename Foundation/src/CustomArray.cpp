///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Contains a custom array class.
 *	\file		IceCustomArray.cpp
 *	\author		Pierre Terdiman
 *	\date		January, 15, 1999
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Customized import/export array.
 *
 * Notes	: 
 *
 * CustomArray is a special array class especially designed for import/export goals, even if you can use it in many other ways.
 * Here are some basic usages and code examples:
 *
 * 1) Saving heterogeneous data to disk
 *
 *	Say you want to create a chunk-based file (e.g. a .3DS one). Such files may contain a chunk type (e.g. "FACE", i.e. a string) followed by
 *	chars or ints (e.g. vertex references) or floats (e.g. vertices). Saving such a file may be painful, and is usually done with an ugly list
 *	of putc/fputc. It also can be done with a single fwrite, but you must have stored your heterogeneous data beforehand, hence usually dealing
 *	with multiple pointers (e.g. a char*, an int*, a float*...) Well, that's ugly. With the CustomArray class you can solve this problem in an
 *	elegant way, with the following code:
 *
 *	\code
 *		CustomArray	Array;				// constructor does all the painful stuff for you, destructor frees everything as well
 *
 *		// Store heterogeneous data in any order...
 *		Array.Store((char)1);
 *		Array.Store(10.0f);
 *		Array.Store((long)1);
 *		Array.Store("Test");
 *
 *		// ...and just save to disk
 *		Array.ExportToDisk("c:\\datas.bin");
 *	\endcode
 *
 *	Saved file is a linear binary file, made of following bytes:
 *	- 01
 *	- 10.0 in float
 *	- 00 00 00 01 (or 01 00 00 00, depends on your computer's little/big endian way of dealing with data)
 *	- the string "Test" (not ended by a NULL character)
 *
 *	And that's all. Very easy to use, and you don't have to know how many bytes you'll need. This is very useful when packing a file for example,
 *	as explained in the second example.
 *
 *
 * 2) Packing a buffer
 *
 *	Say you want to encode a buffer with an arithmetic coder, and your encoder gives you one packed byte at a time. You don't know the final packed size,
 *	but you don't need it if you use a CustomArray.
 *
 *	\code
 *		CustomArray	Array;
 *		int EncodedByte;
 *
 *		do
 *		{
 *			EncodedByte = EncodeSymbol();						// Get next packed byte or EOF (-1)
 *			if(EncodedByte!=EOF)	Array.Store(EncodedByte);	// Save packed byte
 *		}while(EncodedByte!=EOF);
 *
 *		Array.ExportToDisk("c:\\packed.bin");					// Save packed file
 *	\endcode
 *
 *	You even can store bits in your CustomArray, with the StoreBit method. Call the StoreBit method 8 times, and a new byte will be added to the array.
 *	If you call StoreBit, say 6 times, and then call a standard Store method, 2 extra bits are automatically added to padd the address on a byte boundary.
 *
 *
 *	Now let's say you want your saved file to begin with the size of the packed data. (you could take the file's length, but imagine the packed data
 *	is part of a bigger file) As you don't know the final packed size before actually having packed it, this is painful: you must leave room for the
 *	final packed size at the start of the file, and fill it at the end of the process. If you save your file with some putc/fputc this is a real pain.
 *	The CustomArray class has a neat way of dealing with this problem: the PushAddress and PopAddressAndStore methods. Let's modify the example code:
 *
 *	\code
 *		CustomArray	Array;
 *		int EncodedByte;
 *		long PackedSize = 0;
 *
 *		Array.Store((long)0).PushAddress();						// Leave room for a long, save the address
 *
 *		do
 *		{
 *			EncodedByte = EncodeSymbol();						// Get next packed byte or EOF (-1)
 *			if(EncodedByte!=EOF)	Array.Store(EncodedByte);	// Save packed byte
 *			if(EncodedByte!=EOF)	PackedSize++;				// Update packed size
 *		}while(EncodedByte!=EOF);
 *
 *		Array.PopAddressAndStore(PackedSize);					// Store packed size where the PushAddress has been done.
 *
 *		Array.ExportToDisk("c:\\packed.bin");					// Save packed file
 *	\endcode
 *
 *	Of course you can push more than one address (as many as you want):
 *
 *	\code
 *		Array.Store((long)0).PushAddress();						// Push address 1 on the stack
 *		Array.Store((long)0).PushAddress();						// Push address 2 on the stack
 *		Array.Store((long)0).PushAddress();						// Push address 3 on the stack
 *		...
 *		Array.Store((long)0).PushAddress();						// Push address N on the stack
 *
 *		Array.PopAddressAndStore((long)1);						// Pop address N and store value 1
 *		...
 *		Array.PopAddressAndStore((long)N-2);					// Pop address 3 and store value N-2
 *		Array.PopAddressAndStore((long)N-1);					// Pop address 2 and store value N-1
 *		Array.PopAddressAndStore((long)N);						// Pop address 1 and store value N
 *	\endcode
 *
 * 3) Creating a log file
 *
 *	The StoreASCII methods provide a very easy way to create log files (e.g. for debug purpose). Example:
 *
 *	\code
 *		Array.StoreASCII(10.0f);		// Store the string "10.0"
 *		Array.StoreASCII((long)1234);	// Store the string "1234"
 *		Array.StoreASCII(Boolean);		// Store the string "true" or "false", depends on the boolean value
 *	\endcode
 *
 *		Say "Score" is an NxU32 whose value is 500:
 *	\code
 *		Array.StoreASCII("Your score is ").StoreASCII(Score).StoreASCII(".\n");		// Store the string "Your score is 500." (followed by a carriage return)
 *	\endcode
 *
 *		...and so on...
 *
 *
 * 4) Getting the data back
 *
 *	This is easily done with the Collapse method, which creates a linear buffer filled with all stored data.
 *
 *
 * 5) Importing data
 *
 *	You can initialize a CustomArray with your own buffer, or even with a file:
 *
 *	\code
 *		CustomArray	Array("c:\\data.bin");		// Read the whole file data.bin, fill the array with it
 *
 *		MyByte	= Array.GetByte();				// Get the first byte of the array, move the inner pointer one byte beyond
 *		MyFloat	= Array.GetFloat();				// Get the next 4 bytes of the array, read as a float, move the inner pointer 4 bytes beyond
 *		...
 *	\endcode
 *
 *
 *
 * History	:
 *	-	01/15/99:	first version for Irion MAX Plug-In.
 *	-	02/04/99:	ASCII support added.
 *	-	02/05/99:	GetOffset(), Padd(), LinkTo(CustomArray* array) added.
 *	-	03/xx/99:	Collapse() added, self-references added.
 *	-	03/xx/99:	BOOL definition added in header if not defined yet, addies-stack mecanism added.
 *	-	04/xx/99:	"push" renamed to "store", for a more coherent name since people were expecting a "pop" method to be used.............
 *	-	04/xx/99:	BOOL handled as a long. Use bool (in lower case) for a real boolean value.
 *	-	05/xx/99:	heap size is now 4Kb, and allocated ram is doubled for each new block. The more you eat,
 *					the more ram you're given.
 *	-	09/xx/99:	bit-storage methods added (StoreBit, EndBits) for data-compression.
 *	-	10/29/99:	bug fixed: mLastAddress was not initialized. Was crashing if the first thing done was a PushAddress.
 *					Well, a PushAddress should NOT be the first thing done anyway!
 *	-	11/04/99:	address stack is now resizable.
 *	-	01/06/00:	local memory manager and local error codes removed, CustomArray class added to IrionBasics.
 *	-	04/01/00:	CustomArray included in ICE.
 *	-	08/27/00:	little code lifting
 *	-	02/16/02:	added a StoreASCII method for a formated string
 *	-	05/05/02:	bug fixed: Store(sbyte) was actually calling Store(int) because a "char" is not a "sbyte" NOR a "NxU8"...
 *					Thanks to Jere Sanisalo for the report.
 *	-	10/13/02:	CustomBlock & CustomCell structures rewritten, some previously inlined methods moved to the CPP.
 *	-	12/04/02:	bug fixed: internal used size was not correctly initialized when the array was built from a buffer
 *					added copy ctor and assignment operator.
 *					removed obsolete LinkTo() method.
 *	-	12/29/02:	bug fixed: now GetXXX() methods reset bit counter, so we can interleave bits & bytes.
 *	-	02/21/03:	const correctness & some mutable added
 *
 * More notes:
 *	-	always keep in mind that an CustomArray eats CUSTOMARRAY_BLOCKSIZE bytes when initialized, even if you don't use it later.
 *		That's why you may use this class for very specific reasons, or even change this #define to match your own needs.
 *	-	I know I could've used templates.
 *	-	I know it should be rewritten since the design sucks anyway.
 *	-	Oh, well, this class is just too plain old !!! Use at your own risk !
 *
 *	\class		CustomArray
 *	\author		Pierre Terdiman
 *	\version	1.0
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Precompiled Header
//#include "Stdafx.h"

//using namespace IceCore;

#include "CustomArray.h"
#ifdef LINUX
#include <string.h>
#endif

// Quickly hacked support for custom array.... Some code removed, warning.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Gets the size of a given file.
 *	\fn			GetFileSize(const char* name)
 *	\param		name		[in] the filename
 *	\return		the length of the file in bytes
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static NxU32 GetFileSize(const char* name)
{
	#ifndef SEEK_END
	#define SEEK_END 2
	#endif

	FILE* File = fopen(name, "rb");
	if(!File)
	{
//		SetIceError("IceCore::GetFileSize: file not found.", null);
		return 0;
	}
	fseek(File, 0, SEEK_END);
	NxU32 eof_ftell = ftell(File);
	fclose(File);
	return eof_ftell;
}




CustomBlock::CustomBlock()		{ Addy = NULL;			}
CustomBlock::~CustomBlock()		{ NX_DELETE_ARRAY(Addy);	}

CustomCell::CustomCell()		{ NextCustomCell = NULL;	}
CustomCell::~CustomCell()		{							}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Constructor. The first block has a length of start_size bytes, and can be filled with an input_buffer.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray::CustomArray(NxU32 start_size, void* input_buffer) : mNbPushedAddies(0), mNbAllocatedAddies(0), mBitCount(0), mBitMask(0), mAddresses(NULL), mCollapsed(NULL)
{
	Init(start_size, input_buffer, NULL, start_size);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Copy constructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray::CustomArray(CustomArray& array) : mNbPushedAddies(0), mNbAllocatedAddies(0), mBitCount(0), mBitMask(0), mAddresses(NULL), mCollapsed(NULL)
{
	Init(array.GetOffset(), array.Collapse(), NULL, array.GetOffset());
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Constructor. The file whose filename is given is loaded in the first block. Size of the block is the size of the file.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray::CustomArray(const char* filename) : mNbPushedAddies(0), mNbAllocatedAddies(0), mBitCount(0), mBitMask(0), mAddresses(NULL), mCollapsed(NULL)
{
	// Catch the file's size to initialize first block
	NxU32 StartSize = GetFileSize(filename);
	if(!StartSize)	StartSize=CUSTOMARRAY_BLOCKSIZE;

	FILE* fp = fopen(filename, "rb");
	if(fp)
	{
		//fread(mCurrentCell->Item.Addy, StartSize, 1, fp);
		Init(StartSize, NULL, fp, 0);
		fclose(fp);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Destructor. All blocks are released, as well as the possible collapsed array (whose address is then no more valid)
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray::~CustomArray()
{
	Empty();
}

CustomArray& CustomArray::operator=(CustomArray& array)
{
	Empty();
	Init(array.GetOffset(), array.Collapse(), NULL, array.GetOffset());
	return *this;
}

void CustomArray::Init(NxU32 start_size, void* input_buffer, FILE* fp, NxU32 used_size)
{
	// Initialize first export block
	NewBlock(NULL, start_size);

	// Keep track of this first cell
	mInitCell = mCurrentCell;

	// Fill first block with provided buffer, if needed
	if(input_buffer || fp)
	{
		if(input_buffer)	memcpy(mCurrentCell->Item.Addy, input_buffer, start_size);
		else if(fp)			fread(mCurrentCell->Item.Addy, start_size, 1, fp);

		mCurrentCell->Item.Size = used_size;
	}

	// Initialize mLastAddress so that it won't crash if the first thing you ever do is a PushAddress/PopAddressAndStore!!
	mLastAddress = mCurrentCell->Item.Addy;
}

CustomArray& CustomArray::Clean()
{
	Empty();

	// Initialize first export block
	NewBlock(NULL, CUSTOMARRAY_BLOCKSIZE);

	// Keep track of this first cell
	mInitCell = mCurrentCell;

	// Initialize mLastAddress so that it won't crash if the first thing you ever do is a PushAddress/PopAddressAndStore!!
	mLastAddress = mCurrentCell->Item.Addy;

	return *this;
}

CustomArray& CustomArray::Empty()
{
	// Free possible collapsed array
	NX_DELETE_ARRAY(mCollapsed);

	// Free possible adress list
	NX_DELETE_ARRAY(mAddresses);

	// Free linked list
	CustomCell* CurCell = mInitCell;
	while(CurCell)
	{
		CustomCell* Cell = CurCell;
		CurCell = CurCell->NextCustomCell;
		NX_DELETE_SINGLE(Cell);
	}
	return *this;
}





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MANAGEMENT METHODS
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Creates and links a new block to previous ones.
 *	'size' is only used if previous_cell is NULL (i.e. for the first cell).
 *	\param		previous_cell	[in] the previous cell, or NULL if this is the first.
 *	\param		size			[in] number of bytes to allocate for the first cell.
 *	\return		true if success
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CustomArray::NewBlock(CustomCell* previous_cell, NxU32 size)
{
	// Create a new cell
	CustomCell* Cell = new CustomCell;
//	CHECKALLOC(Cell);

	// If a previous cell exists, doubles the needed ram, else get default size
	Cell->Item.Max = previous_cell ? previous_cell->Item.Max*2 : size;

	// Get some bytes for this cell
	Cell->Item.Addy = (void*)new NxU8[Cell->Item.Max];
//	CHECKALLOC(Cell->Item.Addy);
	Cell->Item.Size = 0;

	mCurrentCell = Cell;

	// Update linked list
	if(previous_cell) previous_cell->NextCustomCell = mCurrentCell;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Checks whether there's enough room in current block for expected datas, or not.
 *	A new block is created if there's no more space left in current block.
 *	\param		bytes_needed	[in] number of expected bytes
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::CheckArray(NxU32 bytes_needed)
{
	NxU32 ExpectedSize = mCurrentCell->Item.Size + bytes_needed;
	if(ExpectedSize > mCurrentCell->Item.Max)	NewBlock(mCurrentCell);
	// I assume there IS enough room in the new block for expected data. It should always be the case since 'bytesneeded' is not supposed to be larger than 8
	// (i.e. sizeof(double))
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Exports an array to disk.
 *	\param		filename	[in] the destination file's name.
 *	\param		access		[in] a possible custom access, or NULL
 *	\return		true if success
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CustomArray::ExportToDisk(const char* filename, const char* access)
{
	FILE* fp = access ? fopen(filename, access) : fopen(filename, "wb");
	if(!fp) return false;
	bool Status = ExportToDisk(fp);
	fclose(fp);
	return Status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Exports an array to disk.
 *	\param		fp		[in] the file pointer.
 *	\return		true if success
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CustomArray::ExportToDisk(FILE* fp)
{
	// Fill possible remaining bits with 0
	EndBits();

	CustomCell* p = mInitCell;

	while(p->NextCustomCell)
	{
		// Save current cell
		if(!SaveCell(p, fp)) return false;
		// Go to next cell
		p = p->NextCustomCell;
	}
	// Save last cell
	if(!SaveCell(p, fp)) return false;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Writes a single cell to disk.
 *	\param		p		[in] current cell.
 *	\param		fp		[in] file pointer
 *	\return		true if success
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CustomArray::SaveCell(CustomCell* p, FILE* fp)
{
	NxU32 BytesToWrite = p->Item.Size;
	if(!BytesToWrite) return true;
	if(fwrite(p->Item.Addy, 1, BytesToWrite, fp)!=BytesToWrite) return false;
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Gets current number of bytes stored.
 *	\return		number of bytes stored
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
NxU32 CustomArray::GetOffset()	const
{
	NxU32 Offset = 0;
	CustomCell* p = mInitCell;

	while(p->NextCustomCell)
	{
		// Add offset from current cell
		Offset+=p->Item.Size;
		// Go to next cell
		p = p->NextCustomCell;
	}
	// Add offset from last cell
	Offset+=p->Item.Size;

	return Offset;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Padds offset on a 8 bytes boundary.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Padd()
{
	// Fill possible remaining bits with 0
	EndBits();

	NxU32 Offset = GetOffset();
	NxU32 NbPadd = Offset - (Offset & 7);
	for(NxU32 i=0;i<NbPadd;i++) Store((char)0);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Links 2 arrays.
 *	\param		array		[in] the array to link
 *	\return		Self-Reference
 *	\bug		OBSOLETE CODE
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
CustomArray& CustomArray::LinkTo(CustomArray* array)
{
	NX_ASSERT(0);
	// ### THIS METHOD NEEDS RECODING & TESTING

	CustomCell* p = mInitCell;
	char* Addy;
	NxU32 i;

	while(p->NextCustomCell)
	{
		// Link current cell
		Addy = (char*)p->Item.Addy;
		for(i=0;i<p->Item.Size;i++) Store(*Addy++);

		// Go to next cell
		p = p->NextCustomCell;
	}
	// Link last cell
	Addy = (char*)p->Item.Addy;
	for(i=0;i<p->Item.Size;i++) Store(*Addy++);

	return *this;
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Collapses a CustomArray into a single continuous buffer. This invalidates all pushed addies.
 *	If you provide your destination buffer original bytes are copied into it, then it's safe using them.
 *	If you don't, returned address is valid until the array's destructor is called. Beware of memory corruption...
 *	\param		user_buffer		[out] destination buffer (provided or not)
 *	\return		destination buffer
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void* CustomArray::Collapse(void* user_buffer)
{
	// Fill possible remaining bits with 0
	EndBits();

	char* Addy;
	CustomCell* p = mInitCell;

	if(!user_buffer)
	{
		NX_DELETE_ARRAY(mCollapsed);						// Free possibly already collapsed array
		NxU32 CurrentSize = GetOffset();
		mCollapsed = CurrentSize ? new NxU8[CurrentSize] : NULL;
		Addy = (char*)mCollapsed;
	}
	else
	{
		Addy = (char*)user_buffer;
	}

	char* AddyCopy = Addy;
	if(Addy)
	{
		while(p->NextCustomCell)
		{
			// Collapse current cell
			memcpy(Addy, p->Item.Addy, p->Item.Size);
			Addy+=p->Item.Size;

			// Go to next cell
			p = p->NextCustomCell;
		}
		// Collapse last cell
		memcpy(Addy, p->Item.Addy, p->Item.Size);
		Addy+=p->Item.Size;
		mNbPushedAddies=0;
	}
	return AddyCopy;
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// STORE METHODS
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Prepares for an access.
 *	\param		size	[in] expected number of bytes involved
 *	\return		storage address
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void* CustomArray::PrepareAccess(NxU32 size)
{
	mLastAddress = GetAddress();
	mCurrentCell->Item.Size+=size;
	return mLastAddress;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a BOOL.
 *	\param		bo	[in] BOOL to store
 *	\return		Self-Reference
 *	\warning	BOOL actually is an int. Converted to long.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(NX_BOOL bo)
{
	long b = (long)bo;

	// Fill possible remaining bits with 0
	EndBits().CheckArray(sizeof(long));

	long* Current = (long*)PrepareAccess(sizeof(long));
	*Current=b;
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a bool.
 *	\param		bo	[in] bool to store
 *	\return		Self-Reference
 *	\warning	Converted to char.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(bool bo)
{
	char b = bo ? 1 : 0;

	// Fill possible remaining bits with 0
	EndBits().CheckArray(sizeof(char));

	char* Current = (char*)PrepareAccess(sizeof(char));
	*Current=b;
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a char.
 *	\param		b	[in] char to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(char b)
{
	// Fill possible remaining bits with 0
	EndBits().CheckArray(sizeof(char));

	char* Current = (char*)PrepareAccess(sizeof(char));
	*Current=b;
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a short.
 *	\param		w	[in] short to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(short w)
{
	// Fill possible remaining bits with 0
	EndBits().CheckArray(sizeof(short));

	short* Current = (short*)PrepareAccess(sizeof(short));
	*Current=w;
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores an NxU32.
 *	\param		d	[in] NxU32 to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(NxU32 d)
{
	// Fill possible remaining bits with 0
	EndBits().CheckArray(sizeof(NxU32));

	NxU32* Current = (NxU32*)PrepareAccess(sizeof(NxU32));
	*Current=d;
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a float.
 *	\param		d		[in] float to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(float f)
{
	// Fill possible remaining bits with 0
	EndBits().CheckArray(sizeof(float));

	float* Current = (float*)PrepareAccess(sizeof(float));
	*Current=f;
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a double.
 *	\param		d		[in] double to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(double f)
{
	// Fill possible remaining bits with 0
	EndBits().CheckArray(sizeof(double));

	double* Current = (double*)PrepareAccess(sizeof(double));
	*Current=f;
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a string.
 *	\param		string		[in] the string to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(const char* string)
{
	// Fill possible remaining bits with 0
	EndBits();

	if(string)
	{
		NxU32 Length = strlen(string);
		while(Length--)
		{
			Store((char)*string++);
		}
	}
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a buffer. Only available in binary mode.
 *	\param		buffer		[in] the input buffer.
 *	\param		size		[in] the buffer size.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(void* buffer, NxU32 size)
{
	if(buffer)
	{
		// Fill possible remaining bits with 0
		EndBits();

		NxU8* p = (NxU8*)buffer;
		while(size--)
		{
			Store(*p++);
		}
	}
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a CustomArray. Only available in binary mode.
 *	\param		array		[in] the input CustomArray
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(CustomArray* array)
{
	if(array)	Store(array->Collapse(), array->GetOffset());
	return *this;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// STOREASCII METHODS
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores an ASCII code.
 *	\param		code		[in] input byte.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCIICode(char code)
{
	// Fill possible remaining bits with 0
	EndBits().CheckArray(sizeof(char));

	char* Current = (char*)PrepareAccess(sizeof(char));
	*Current=code;
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a BOOL in ASCII.
 *	\param		bo		[in] the BOOL to store.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(NX_BOOL bo)
{
	char Text[256];
	sprintf(Text, "%d", (long)bo);
	StoreASCII((const char*)Text);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a bool in ASCII.
 *	\param		bo		[in] the bool to store.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(bool bo)
{
	if(bo)	StoreASCII((const char*)"true");
	else	StoreASCII((const char*)"false");
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a char in ASCII.
 *	\param		b		[in] the char to store.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(char b)
{
	char Text[256];
	sprintf(Text, "%d", b);
	StoreASCII((const char*)Text);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores an NxU8 in ASCII.
 *	\param		b		[in] the NxU8 to store.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(NxU8 b)
{
	char Text[256];
	sprintf(Text, "%u", b);
	StoreASCII((const char*)Text);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a short in ASCII.
 *	\param		w		[in] the short to store.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(short w)
{
	char Text[256];
	sprintf(Text, "%d", w);
	StoreASCII((const char*)Text);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores an NxU16 in ASCII.
 *	\param		w		[in] the NxU16 to store.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(NxU16 w)
{
	char Text[256];
	sprintf(Text, "%u", w);
	StoreASCII((const char*)Text);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a long in ASCII.
 *	\param		d		[in] the long to store.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(long d)
{
	char Text[256];
	sprintf(Text, "%d", d);
	StoreASCII((const char*)Text);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores an unsigned long in ASCII.
 *	\param		d		[in] the unsigned long to store.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(unsigned long d)
{
	char Text[256];
	sprintf(Text, "%u", d);
	StoreASCII((const char*)Text);
	return *this;
}

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Stores an int in ASCII.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Input	:	d		= the int to store.
// Output	:	-
// Return	:	Self-Reference
// Remark	:	-
CustomArray& CustomArray::StoreASCII(int d)
{
	char Text[256];
	sprintf(Text, "%d", d);
	StoreASCII((const char*)Text);
	return *this;
}
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores an unsigned int in ASCII.
 *	\param		d		[in] the unsigned int to store.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(unsigned int d)
{
	char Text[256];
	sprintf(Text, "%u", d);
	StoreASCII((const char*)Text);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a float in ASCII.
 *	\param		f		[in] the float to store.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(float f)
{
	char Text[256];
	sprintf(Text, "%f", f);
	StoreASCII((const char*)Text);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a double in ASCII.
 *	\param		f		[in] the double to store.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(double f)
{
	char Text[256];
	sprintf(Text, "%f", f);
	StoreASCII((const char*)Text);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a string in ASCII.
 *	\param		string		[in] the string to store.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(const char* string)
{
	// Fill possible remaining bits with 0
	EndBits();

	if(string)
	{
		NxU32 Length = strlen(string);
		for(NxU32 i=0;i<Length;i++)
		{
			if(string[i]=='\n')
			{
				NX_ASSERT(0);
//				StoreASCIICode((char)ASCII_CARRIAGE_RETURN);
//				StoreASCIICode((char)ASCII_NEXT_LINE);
			}
			else 
				StoreASCIICode((char)string[i]);
		}
	}
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Stores a formated string in ASCII.
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
CustomArray& CustomArray::StoreASCII(LPSTR fmt, ...)
{
	static char buff[4096];

	va_list va;

	va_start(va, fmt);
	vsprintf(buff, fmt, va);
	va_end(va); 

	if(strlen(buff)>=4096)
	{
		IceCore::MessageBox(NULL, "CustomArray::StoreASCII:: buffer overflow!!", "Fatal error", MB_OK);
	}

	return StoreASCII((const char*)buff);
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// BIT STORAGE METHODS
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
*	Padds bits on a byte.
*	\return		Self-Reference
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::EndBits()
{
	while(mBitCount)	StoreBit(false);
	return *this;
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// PUSH/POP ADDRESS METHODS
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Pushes current address into the address-stack for later processing.
 *	\return		true if success, else false
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CustomArray::PushAddress()
{
	// Check available space and resize if needed.
	if((mNbPushedAddies+1)>mNbAllocatedAddies)
	{
		// Here we must resize. We get twice as much bytes as already allocated in order to minimize total #resizes.
		NxU32 NewSize = mNbAllocatedAddies ? mNbAllocatedAddies * 2 : 1;

		// Create new buffer...
		void** Addresses = new void*[NewSize];
		if(!Addresses)	return false;

		// ...copy & release old one to new one if old one exists...
		if(mNbAllocatedAddies)
		{
			memcpy(Addresses, mAddresses, mNbAllocatedAddies * sizeof(void*));
			NX_DELETE_ARRAY(mAddresses);
		}

		// ...and set new members.
		mAddresses			= Addresses;
		mNbAllocatedAddies	= NewSize;
	}

	// Save last address
	mAddresses[mNbPushedAddies++] = mLastAddress;
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Pops an address and stores a BOOL where the poped address tells.
 *	\param		bo			[in] the BOOL to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(NX_BOOL bo)
{
	if(mNbPushedAddies)
	{
		NX_BOOL* Addy = (NX_BOOL*)mAddresses[--mNbPushedAddies];
		*Addy=bo;
	}
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Pops an address and stores a bool where the poped address tells.
 *	\param		bo			[in] the bool to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(bool bo)
{
	if(mNbPushedAddies)
	{
		char* Addy = (char*)mAddresses[--mNbPushedAddies];
		*Addy=(char)bo;
	}
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Pops an address and stores a char where the poped address tells.
 *	\param		b			[in] the char to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(char b)
{
	if(mNbPushedAddies)
	{
		char* Addy = (char*)mAddresses[--mNbPushedAddies];
		*Addy=b;
	}
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Pops an address and stores an NxU8 where the poped address tells.
 *	\param		b			[in] the NxU8 to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(NxU8 b)
{
	if(mNbPushedAddies)
	{
		NxU8* Addy = (NxU8*)mAddresses[--mNbPushedAddies];
		*Addy=b;
	}
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Pops an address and stores a short where the poped address tells.
 *	\param		w			[in] the short to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(short w)
{
	if(mNbPushedAddies)
	{
		short* Addy = (short*)mAddresses[--mNbPushedAddies];
		*Addy=w;
	}
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Pops an address and stores an NxU16 where the poped address tells.
 *	\param		w			[in] the NxU16 to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(NxU16 w)
{
	if(mNbPushedAddies)
	{
		NxU16* Addy = (NxU16*)mAddresses[--mNbPushedAddies];
		*Addy=w;
	}
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Pops an address and stores a long where the poped address tells.
 *	\param		d			[in] the long to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(long d)
{
	if(mNbPushedAddies)
	{
		long* Addy = (long*)mAddresses[--mNbPushedAddies];
		*Addy=d;
	}
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Pops an address and stores an unsigned long where the poped address tells.
 *	\param		d			[in] the unsigned long to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(unsigned long d)
{
	if(mNbPushedAddies)
	{
		unsigned long* Addy = (unsigned long*)mAddresses[--mNbPushedAddies];
		*Addy=d;
	}
	return *this;
}
/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Pops an address and store an int where the poped address tells.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Input	:	d		= the int to store
// Output	:	-
// Return	:	Self-Reference
// Remark	:	-
CustomArray& CustomArray::PopAddressAndStore(int d)
{
	if(mNbPushedAddies)
	{
		int* Addy = (int*)mAddresses[--mNbPushedAddies];
		*Addy=d;
	}
	return *this;
}
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Pops an address and stores an unsigned int where the poped address tells.
 *	\param		d			[in] the unsigned int to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(unsigned int d)
{
	if(mNbPushedAddies)
	{
		unsigned int* Addy = (unsigned int*)mAddresses[--mNbPushedAddies];
		*Addy=d;
	}
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Pops an address and stores a float where the poped address tells.
 *	\param		f			[in] the float to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(float f)
{
	if(mNbPushedAddies)
	{
		float* Addy = (float*)mAddresses[--mNbPushedAddies];
		*Addy=f;
	}
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Pops an address and stores a double where the poped address tells.
 *	\param		f			[in] the double to store
 *	\return		Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(double f)
{
	if(mNbPushedAddies)
	{
		double* Addy = (double*)mAddresses[--mNbPushedAddies];
		*Addy=f;
	}
	return *this;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// READ METHODS
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

NxU8 CustomArray::GetByte() const
{
	CustomArray* FakeThis = const_cast<CustomArray*>(this);
	mBitCount=0;
	NxU8* Current = (NxU8*)FakeThis->PrepareAccess(sizeof(NxU8));
	return *Current;
}

NxU16 CustomArray::GetWord() const
{
	CustomArray* FakeThis = const_cast<CustomArray*>(this);
	mBitCount=0;
	NxU16* Current = (NxU16*)FakeThis->PrepareAccess(sizeof(NxU16));
	return *Current;
}

NxU32 CustomArray::GetDword() const
{
	CustomArray* FakeThis = const_cast<CustomArray*>(this);
	mBitCount=0;
	NxU32* Current = (NxU32*)FakeThis->PrepareAccess(sizeof(NxU32));
	return *Current;
}

float CustomArray::GetFloat() const
{
	CustomArray* FakeThis = const_cast<CustomArray*>(this);
	mBitCount=0;
	float* Current = (float*)FakeThis->PrepareAccess(sizeof(float));
	return *Current;
}

NxU8* CustomArray::GetString() const
{
	mBitCount=0;

	NxU8* StringAddress = (NxU8*)GetAddress();

	NxU8 c;
	do{
		c = GetByte();
	}
	while(c);

	return StringAddress;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Sets the current address within current block. Input offset can't be greater than current block's length.
 *	\param		offset	[in] the wanted offset within the block.
 *	\return		Self-Reference.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Reset(NxU32 offset)
{
	if(offset<mCurrentCell->Item.Max)
	{
		// Force new size
		mCurrentCell->Item.Size = offset;
		// Fix last address
		NxU8* CurrentAddy = (NxU8*)mCurrentCell->Item.Addy;
		CurrentAddy+=mCurrentCell->Item.Size;
		mLastAddress = (void*)CurrentAddy;
	}
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Finds a given chunk (a sequence of bytes) in current buffer.
 *	\param		chunk	[in] chunk you're looking for (must end with a NULL byte).
 *	\return		address where the chunk has been found, or NULL if not found.
 *	\warning	chunk length limited to 1024 bytes...
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void* CustomArray::GetChunk(const char* chunk)
{
	// Checkings
	if(!chunk)	return NULL;

	// Get chunk length & check it
	NxU32 ChunkLength = strlen(chunk);
	if(ChunkLength>1023)	return NULL;

	char Data[1024];

	const char* Addy = (const char*)mCurrentCell->Item.Addy;
	Data[ChunkLength]=0;

	NxU32 Length = mCurrentCell->Item.Max-(ChunkLength-1);
	for(NxU32 i=0;i<Length;i++)
	{
		memcpy(Data, Addy, ChunkLength);

		if(strcmp((const char*)Data, chunk)==0)
		{
			NxU32 CorrectAddy = NxU32(Addy+ChunkLength);
			NxU32 CorrectOffset = CorrectAddy - NxU32(mCurrentCell->Item.Addy);
			mCurrentCell->Item.Size = CorrectOffset;
			return (void*)CorrectAddy;
		}
		Addy++;
	}
	return NULL;
}

